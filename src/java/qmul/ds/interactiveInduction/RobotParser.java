package qmul.ds.interactiveInduction;

import org.apache.log4j.Logger;
import qmul.ds.DAGParser;
import qmul.ds.InteractiveContextParser;
import qmul.ds.Utterance;
import qmul.ds.dag.DAGEdge;
import qmul.ds.dag.DAGTuple;
import qmul.ds.formula.TTRRecordType;

import java.io.*;
import java.net.ServerSocket;
import java.net.Socket;
import java.util.HashMap;
import java.util.regex.Matcher;

/**
 * Loads the robotic parser developed by Julian Hough and parses the instruction of the mission.
 */
public class RobotParser {
    static final String grammarPath = "dsttr/resource/2023-babyds-induction-output/".replaceAll("/", Matcher.quoteReplacement(File.separator));
    protected static Logger logger = Logger.getLogger(RobotParser.class);
    public static final String ANSI_RESET = "\u001B[0m";
    public static final String ANSI_GREEN = "\u001B[32m";
    public static final String ANSI_YELLOW = "\u001B[33m";
    public static final String ANSI_BLUE = "\u001B[34m";
    public static final String ANSI_PURPLE = "\u001B[35m";
    public static final String ANSI_CYAN = "\u001B[36m";
    protected static int port = 12345;
    protected DAGParser<? extends DAGTuple, ? extends DAGEdge> parser;  //todo why this is not ICP?
    public static String instruction = "";  // Donno if this is the correct definition of instruction

    // --------------------------------- Constructors ---------------------------------
    public RobotParser(String grammarPath){
        this.parser = new InteractiveContextParser(grammarPath);
    }

    // --------------------------------- Methods ---------------------------------
    public void testRobotParser(String instruction){
        parser.init();
        parser.parseUtterance(new Utterance(instruction));
    }


    /**
     * A method that solves the first level of Baby AI.
     * Solution is generated by measuring the distance between the agent and the goal and then moving the agent towards the goal.
     * It also considers the direction of the agent.
     * @param agentLoc
     * @param goalLoc
     * @param currentDirection
     */
    public static void plan(String agentLoc, String goalLoc, String currentDirection) {
        String solution = "";
//        String goalDirection = "";  // can be N, S, E, W.
        HashMap<String, String> actions = new HashMap<>();
        actions.put("left", "0");
        actions.put("right", "1");
        actions.put("forward", "2");
        actions.put("done", "6");

        // First parse the location strings
        Location agentLocation = new Location(agentLoc);
        Location goalLocation = new Location(goalLoc);

        // Then calculate the distance between the agent and the goal
        int distanceX = goalLocation.getX() - agentLocation.getX();
        int distanceY = goalLocation.getY() - agentLocation.getY();
        logger.info("Distance between agent and goal is: " + distanceX + ", " + distanceY);

        // Then move the agent towards the goal: turn towards the goal by turning left or right and then moving enough x and y.
        // Actions are added to the solution string and then sent to the Python client.
        // First deal with the direction of the agent:
        if (distanceX > 0){
            // Turn right
            if (currentDirection.equals("N")){
                solution += actions.get("right") + " ";
                currentDirection = "E";
            } else if (currentDirection.equals("S")){
                solution += actions.get("left") + " ";
                currentDirection = "E";
            } else if (currentDirection.equals("E")){
                // Do nothing
            } else if (currentDirection.equals("W")){
                solution += actions.get("right") + " ";
                solution += actions.get("right") + " ";
                currentDirection = "E";
            }
        } else if (distanceX < 0){
            // Turn left
            if (currentDirection.equals("N")){
                solution += actions.get("left") + " ";
                currentDirection = "W";
            } else if (currentDirection.equals("S")){
                solution += actions.get("right") + " ";
                currentDirection = "W";
            } else if (currentDirection.equals("E")){
                solution += actions.get("right") + " ";
                solution += actions.get("right") + " ";
                currentDirection = "W";
            } else if (currentDirection.equals("W")){
                // Do nothing
            }
        }

        // Then move the agent towards the goal on the x axis
        for (int i = 0; i < Math.abs(distanceX); i++) {
            solution += actions.get("forward") + " ";
        }

        // Again deal with the direction of the agent:
        if (distanceY > 0){
            // Turn right
            if (currentDirection.equals("N")){
                // Do nothing
            } else if (currentDirection.equals("S")){
                solution += actions.get("right") + " ";
                solution += actions.get("right") + " ";
                currentDirection = "N";
            } else if (currentDirection.equals("E")){
                solution += actions.get("left") + " ";
                currentDirection = "N";
            } else if (currentDirection.equals("W")){
                solution += actions.get("right") + " ";
                currentDirection = "N";
            }
        } else if (distanceY < 0){
            // Turn left
            if (currentDirection.equals("N")){
                solution += actions.get("right") + " ";
                solution += actions.get("right") + " ";
                currentDirection = "S";
            } else if (currentDirection.equals("S")){
                // Do nothing
            } else if (currentDirection.equals("E")){
                solution += actions.get("right") + " ";
                currentDirection = "S";
            } else if (currentDirection.equals("W")){
                solution += actions.get("left") + " ";
                currentDirection = "S";
            }
        }

        // Then move the agent towards the goal on the y axis
        for (int i = 0; i < Math.abs(distanceY); i++) {
            solution += actions.get("forward") + " ";
        }

        // Send the solution to the Python client
        logger.info(ANSI_BLUE + "Solution is: " + solution + ANSI_RESET);
        try (Socket socket = new Socket("localhost", port)) {
            try (PrintWriter out = new PrintWriter(socket.getOutputStream(), true)) {
                out.println(solution);
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }


    /**
     * Process the INSTR data from the current connection.
     * instruction is sent word by word and the first word begins with "INSTR" and the last word ends with "END".
     */
    public static void processINSTR(String instructionWord) {
        instruction += instructionWord + " ";
        logger.info(ANSI_YELLOW + "Currently received instruction is: " + instruction + ANSI_RESET);
//        logger.info("Received instruction from Python: " + instructionString);
//        parser.init();
//        parser.parseUtterance(new Utterance(instructionString));
    }

    /**
     * Process the TTR data from the current connection.
     * TTR is sent word by word and the first word begins with "TTR" and the last word ends with "END".
     */
    public static void processTTR(String rtString) {
        logger.info(ANSI_PURPLE + "Received TTR is: " + rtString + ANSI_RESET);
        TTRRecordType rt = TTRRecordType.parse(rtString);
        logger.info("Received TTR is: " + rt);
    }


    /**
     * Process the UPDATE data from the current connection.
     * UPDATE is sent word by word and the first word begins with "UPDATE" and the last word ends with "END".
     */
    public static void processUpdate(String updateString) {
        logger.info(ANSI_PURPLE + "Received update is: " + updateString + ANSI_RESET);
        switch (updateString) {
            case "AT":
                logger.info(ANSI_GREEN + "AT update received." + ANSI_RESET);
//                Observation.update_AT();
                break;
            default:
                logger.info(ANSI_GREEN + "Unknown update received." + ANSI_RESET);
                break;
        }
    }


    /**
     * Process the data from the current connection. data can be of different types, so I assume the string
     * starts with the type of processing that needs to be done.
     * @param data
     */
    public static void processReceivedData(String data) {
        // Extract the data type from the input
        String dataType = data.split(" ", 2)[0];
        String dataStr = data.split(" ", 2)[1];

        // Switch statement to handle different data types
        switch (dataType) {
            case "INSTR_STR":
                processINSTR(dataStr);
                break;
            case "INSTR_TTR":
                processTTR(dataStr);
                break;
            case "NEW_EPS":
                instruction = ""; // reset the instruction
                logger.info(ANSI_CYAN + "New level started: " + ANSI_RESET);  // print name of the level.
                break;
            case "ENV_CONFIG":
                String[] levelInfo = dataStr.split(" ");
                plan(levelInfo[0], levelInfo[1], levelInfo[2]);

            case "UPDATE":
                processUpdate(dataStr);
                break;
            default:
                System.out.println("Unknown data type: " + dataType);
                break;
        }
    }

    /**
     * Generated by CHATGPT
     * @param data
     */
    public static void processConnection(Socket socket) {
        try (BufferedReader in = new BufferedReader(new InputStreamReader(socket.getInputStream()))) {
            String data;

            while ((data = in.readLine()) != null) {  // donno if the logic is correct here.
                logger.info("Received data from Python: " + data);

                // Process the data as needed
                processReceivedData(data);
                // Optionally, send a response back to the Python client
                try (PrintWriter out = new PrintWriter(socket.getOutputStream(), true)) {
                    out.println("Java server received: " + data); // TODO the heck is this?
                }
            }
            // Connection closed by the client
            logger.info("Connection closed by Python client: " + socket.getInetAddress());
        } catch (IOException e) {
            e.printStackTrace();
        }
    }


    public static void main(String[] args) {
        logger.info("Starting RobotParser...");
//        Observation obs = new Observation();
//        SocketReceiver receiver = new SocketReceiver();
//        logger.info("Socket created. Receiving data in progress.");
        // TODO Later, it will be more than just instructions, so maybe I should use switch case to handle this,
        //  and a better variable name and use indicators of type of data being received at the beginning as a string.
//        String instruction = receiver.receive();

        // Below definitely has to be added to a separate method for cleaner code.
//         Solution provided by chatGPT for receiving a stream of words, not a single sentence. TODO
//        try (ServerSocket serverSocket = new ServerSocket(port)) {
//            System.out.println("Java server is listening on port " + port);
//
//            while (true) {
//                // Accept a new connection
//                Socket socket = serverSocket.accept();
//                System.out.println("Connected to Python client: " + socket.getInetAddress());
//
//                // Process the data from the current connection
//                processConnection(socket);
//            }
//        } catch (IOException e) {
//            e.printStackTrace();
//        }

        String instruction = "go to the red box";
        RobotParser roboParser = new RobotParser(grammarPath);
        logger.info("roboParser loaded.");
//        logger.info("Received data from Python: " + instruction);
        roboParser.testRobotParser(instruction);
//        roboParser.parser.init();
//        parser.parse(instruction);
    }

}
