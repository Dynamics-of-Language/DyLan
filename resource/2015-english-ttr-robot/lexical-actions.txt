// Lexical actions for English
// as per Dynamics of Conversational Dialogue project, 2009

// Rule metavariables: uppercase rule spec arguments
// Formula metavariables: A,B,C
// Bottom requirement: !


//*
Nouns and pronouns
*//
proper(NAME,PERSON,CLASS)
IF      ?ty(e)
THEN    put(person(PERSON))
        put(class(CLASS))
        put(ty(e))
        ttrput([x==NAME:e|head==x:e])
ELSE    abort


mass(NAME,PERSON,CLASS)
IF      ?ty(e)
THEN    put(ty(e))
        ttrput([x==NAME:e|head==x:e])
        put(person(PERSON))
        put(class(CLASS))
        put(!)
ELSE    abort


count(PRED,PERSON,CLASS)
IF      ?ty(cn)
		Fo(X)
THEN 	delete(Fo(X))
		make(\/1)
        go(\/1)
        ttrput(R^(R ++ [p3==PRED(R.head):t]))
        put(ty(e>cn))      
        go(/\1)
        make(\/0)
        go(\/0)
        ttrput([head==x:e])
        put(ty(e))
        go(/\0)
ELSE    abort

count_def(PRED,PERSON,CLASS)
IF      ?ty(e)
THEN    put(person(s3))	
		make(\/1)
        go(\/1)
        ttrput(R^[r:R | x1==(iota, r.head, r):e | head==x1:e])
        put(ty(cn>e))
        put(!)
        go(/\1)
        make(\/0)
        go(\/0)
        put(?ty(cn))
        make(\/1)
        go(\/1)
        ttrput(R^(R ++ [p3==PRED(R.head):t]))
        put(ty(e>cn))      
        put(!)
        go(/\1)
        make(\/0)
        go(\/0)
        ttrput([head==x:e])
        put(ty(e))
        put(!)
ELSE	abort

pron_whq(CLASS)
IF		?ty(e)
		</\*>?ty(t)
THEN	put(ty(e))
		put(fo([x:e|head==x:e]))
		put(class(CLASS))
ELSE	abort



pron_nom(PERSON,CLASS)
IF      ?ty(e)
        </\U>?ty(t)
THEN    put(ty(e))
        ttrput([x:e|head==x:e])
        put(?Ex.fo(x))
        put(person(PERSON))
        put(class(CLASS))
        put(!)
ELSE    abort


pron_acc(PERSON,CLASS)
IF      ?ty(e)
        </\0>?ty(e>X)
THEN    put(ty(e))
        ttrput([x:e|head==x:e])
        put(?Ex.fo(x))
        put(person(PERSON))
        put(class(CLASS))
        put(!)
ELSE    abort

pron_dative(PERSON,CLASS)
IF      ?ty(e)
THEN	put(+dat)
		put(ty(e))
        ttrput([x==PERSON:e|head==x:e])
        put(?Ex.fo(x))
        put(person(PERSON))
        put(class(CLASS))
        put(!)
ELSE    abort

dative_particle(PRED)
IF      ?ty(e)
THEN	put(+dat)
ELSE	abort


//*
pron_ref(PERSON,CLASS)
IF		?ty(e)
		¬</\0>?ty(es>t)
		</\0/\*\/0>(ty(e)& fo(X)& class(CLASS)& person(PERSON))
THEN	put(fo(X))
		put(ty(e))
		put(person(PERSON))
		put(class(CLASS))
		put(!)
ELSE	abort


pron_whrel(CLASS)
IF      ?ty(e)
        </\*/\L>fo(X)
THEN    put(ty(e))
        put(fo(X))
ELSE    abort
*//


//*
Determiners
*//
det_quant(QUANT)
IF      ?ty(e)
THEN    put(person(s3))	
		make(\/1)
        go(\/1)
        ttrput(R^[r:R | x1==(QUANT, r.head, r):e | head==x1:e])
        put(ty(cn>e))
        put(!)
        go(/\1)
        make(\/0)
        go(\/0)
        put(?ty(cn))
        ttrput([x:e|head:x])
ELSE    abort


//*
Adjectives
*//
adj(PRED)
IF      (?ty(cn)||?ty(e))
THEN    IF		?ty(e)
		THEN	make(\/1)
        		go(\/1)
        		ttrput(R^[r:R | x1==(iota, r.head, r):e | head==x1:e])
        		put(ty(cn>e))
        		put(!)
        		go(/\1)
        		make(\/0)
        		go(\/0)
        		put(?ty(cn))
        		ttrput([x:e|head:x])
		ELSE	do_nothing
		IF      ?ty(cn)
				Fo(X)
		THEN    delete(Fo(X))
				make(\/1)
		        go(\/1)
		        ttrput(R^(R ++ [p3==PRED(R.head):t]))
		        put(ty(cn>cn))
		        put(!)
		        go(/\1)
		        make(\/0)
		        go(\/0)
		        ttrput([x:e|head==x:e])
		        put(?ty(cn))
	 	ELSE	make(\/1)
		        go(\/1)
		        ttrput(R^(R ++ [p3==PRED(R.head):t]))
		        put(ty(cn>cn))
		        put(!)
		        go(/\1)
		        make(\/0)
		        go(\/0)
		        ttrput([x:e|head==x:e])
		        put(?ty(cn))
ELSE    abort


//*
VERBS
*//

v_intran_inf(PRED,TENSE,PERSON)
IF		ty(e>t)
        ?Ex.fo(x)
        ¬<\/0>Ex.x
        ¬<\/1>Ex.x
THEN	delete(?Ex.fo(x))
		v_intran_content(PRED)
ELSE	abort

v_intran_fin(PRED,TENSE,PERSON)
IF		?ty(e>t)
		//</\1\/0>person(PERSON)	
THEN	put(?+eval)
		make(\/L)
		go(\/L)
		put(ty(t))
		event_restrictor(TENSE)
		go(/\L)
		put(ty(e>t))
		delete(?ty(e>t))		
		put(?Ex.fo(x))
ELSE	abort
IF		ty(e>t)
        ?Ex.fo(x)
        ¬<\/0>Ex.x
        ¬<\/1>Ex.x
THEN	delete(?Ex.fo(x))
		v_intran_content(PRED)
ELSE	abort  

v_intran_fin_imperative(PRED,TENSE,PERSON)
IF		?ty(e)
		</\0\/1>Ex.x
THEN	put(ty(e))
		delete(?ty(e))
		ttrput([x==addressee:e|head==x:e])
		go(/\0)
		go(\/1)	
		put(?+eval)
		make(\/L)
		go(\/L)
		put(ty(t))
		event_restrictor(TENSE)
		put(?+eval)
		make(\/L)
		go(\/L)
		put(ty(t))
		ttrput([head:es|p1==imperative(head):t])
		go(/\L)
		go(/\L)
		v_intran_content(PRED)
ELSE	abort


v_tran_inf(PRED,TENSE,PERSON)
IF		ty(e>t)
        ?Ex.fo(x)
        ¬<\/0>Ex.x
        ¬<\/1>Ex.x
THEN	delete(?Ex.fo(x))
		delete(ty(e>t))
		put(?ty(e>t))		
		v_tran_content(PRED)
ELSE    abort


v_tran_fin(PRED,TENSE,PERSON)
IF		?ty(e>t)
		//</\1\/0>person(PERSON)
THEN	put(?+eval)
		make(\/L)
		go(\/L)
		put(ty(t))
		event_restrictor(TENSE)
		go(/\L)
		put(ty(e>t))	
		delete(?ty(e>t))	
		put(?Ex.fo(x))		
ELSE	abort
IF		ty(e>t)
        ?Ex.fo(x)
        ¬<\/0>Ex.x
        ¬<\/1>Ex.x
THEN	delete(?Ex.fo(x))
		delete(ty(e>t))
		put(?ty(e>t))		
		v_tran_content(PRED)
ELSE    abort

v_tran_fin_imperative(PRED,TENSE,PERSON)
IF		?ty(e)
		</\0\/1>Ex.x
THEN	put(ty(e))
		delete(?ty(e))
		ttrput([x==addressee:e|head==x:e])
		go(/\0)
		go(\/1)	
		put(?+eval)
		make(\/L)
		go(\/L)
		put(ty(t))
		event_restrictor(TENSE)
		put(?+eval)
		make(\/L)
		go(\/L)
		put(ty(t))
		ttrput([head:es|p1==imperative(head):t])
		go(/\L)
		go(/\L)
		v_tran_content(PRED)
ELSE	abort

v_ditran_fin_imperative(PRED,TENSE,PERSON)
IF		?ty(e)
		</\0\/1>Ex.x
THEN	put(ty(e))
		delete(?ty(e))
		ttrput([x==addressee:e|head==x:e])
		go(/\0)
		go(\/1)
		v_ditran_content(PRED)
ELSE	abort

//*
make(\/L)
		go(\/L)
		put(ty(t))
		event_restrictor(TENSE)
		make(\/L)
		go(\/L)
		put(ty(t))
		ttrput([head:es|p1==imperative(head):t])
		go(/\L)
		go(/\L)

*//

v_ditran_fin_imperative_personal_object(PRED,TENSE,PERSON)
IF		?ty(e)
		</\0\/1>Ex.x
THEN	put(ty(e))
		delete(?ty(e))
		ttrput([x==addressee:e|head==x:e])
		go(/\0)
		go(\/1)	
		put(?+eval)
		make(\/L)
		go(\/L)
		put(ty(t))
		event_restrictor(TENSE)
		put(?+eval)
		make(\/L)
		go(\/L)
		put(ty(t))
		ttrput([head:es|p1==imperative(head):t])
		go(/\L)
		go(/\L)
		v_ditran_content(PRED)
		put(?+dat)
ELSE	abort

v_aux_inf(PRED,TENSE,PERSON)
IF		?ty(e>t)
		¬<\/1>Ex.x
	 	¬<\/0>Ex.x
		</\1\/0>ty(e)
THEN 	aux_content(PRED)
ELSE	IF		?ty(t)
				¬<\/1>Ex.x
	 			¬<\/0>Ex.x				
		THEN	put(+Q)
				make(\/1)
				go(\/1)
				put(?ty(e>t))
				aux_content(PRED)
				go(/\1)
				make(\/0)
				go(\/0)
				put(?ty(e))
		ELSE	abort


//*
PREPOSITIONS AND MODIFIERS
*//
adv(PRED)
IF		(?ty(t) || ty(t) || ty(e>t) || ?ty(e>t) || ?ty(e))
		¬<\/L>Ex.x		
THEN	IF		?ty(e)
		THEN	go(/\0)
				go(\/1)
				put(?+eval)
				make(\/L)
				go(\/L)
				put(ty(t))
				ttrput([head:es|p==PRED(head):t])
		ELSE	put(?+eval)
				make(\/L)
				go(\/L)
				put(ty(t))
				ttrput([head:es|p==PRED(head):t])
ELSE	abort

prep_adv(PRED)
IF		(?ty(t) || ty(t) || ty(e>t) || ?ty(e>t)|| ?ty(e))
		¬<\/L>Ex.x		
THEN	put(?+eval)
		make(\/L)
		go(\/L)
		put(?ty(t))
		make(\/1)
		go(\/1)
		put(ty(e>t))
		ttrput(R1^(R1 ++ [head:es|p==PRED(head,R1.head):t]))
		go(/\1)
		make(\/0)
		go(\/0)
		put(?ty(e))
ELSE	abort

prep_adv_def(PRED)
IF		(?ty(t) || ty(t) || ty(e>t) || ?ty(e>t) || ?ty(e))
		¬<\/L>Ex.x		
THEN	put(?+eval)
		make(\/L)
		go(\/L)
		put(?ty(t))
		make(\/1)
		go(\/1)
		put(ty(e>t))
		ttrput(R1^(R1 ++ [head:es|p==PRED(head,R1.head):t]))
		go(/\1)
		make(\/0)
		go(\/0)
		put(?ty(e))
		make(\/1)
        go(\/1)
        ttrput(R^[r:R | x1==(iota, r.head, r):e | head==x1:e])
        put(ty(cn>e))
        put(!)
        go(/\1)
        make(\/0)
        go(\/0)
        put(?ty(cn))
        ttrput([x:e|head:x])
ELSE	abort

prep_mod_location(PRED)
IF		?ty(e)
THEN	make(\/1)
		go(\/1)
		put(ty(e>e))
		ttrput(R1^(R1 ++ [e1==PRED:es|head:e1|p==obj(head,R1.head):t]))
		put(!)
		go(/\1)
		make(\/0)
		go(\/0)
		put(?ty(e))
ELSE	abort

prep_mod_def(PRED)
IF		(ty(e))
		¬<\/L>Ex.x		
THEN	put(?+eval)
		make(\/L)
		go(\/L)
		put(?ty(t))
		make(\/1)
		go(\/1)
		put(ty(e>t))
		ttrput(R1^(R1 ++ [head:e|p==PRED(head,R1.head):t]))
		go(/\1)
		make(\/0)
		go(\/0)
		put(?ty(e))
		make(\/1)
        go(\/1)
        ttrput(R^[r:R | x1==(iota, r.head, r):e | head==x1:e])
        put(ty(cn>e))
        put(!)
        go(/\1)
        make(\/0)
        go(\/0)
        put(?ty(cn))
        ttrput([x:e|head:x])
ELSE	abort

adjunct_loc_time(PRED)
IF		(?ty(t) || ty(t) || ty(e>t)||?ty(e))
		¬<\/L>Ex.x		
THEN	put(?+eval)
		make(\/L)
		go(\/L)
		put(ty(t))
		ttrput([head:es|p==PRED(head):t])
ELSE	abort

//*
CONNECTIVES.
For entities, as we're dealing with an already complete e node,
we need to de-head the x:e and replace it with a conjunction x==conunction:e
which can be added to
*//

conj_entity(PRED)
IF		ty(e)
		fo(X)
		¬?+eval
		¬</\0\/1>ty(cn>e)
		<\/0>fo(W)
		<\/1>fo(U)
		<\/0\/0>fo(Y)
		<\/0\/1>fo(Z)
THEN	delete(fo(X))
		ttrput([x==conjunction:e|head==x:e])
		put(?+eval)
		go(\/0)
		go(\/0)
		delete(fo(Y))
		ttrput([x==conjunction:e|head==x:e])
		go(/\0)
		go(\/1)
		delete(fo(Z))
		ttrput(R1^(R1 ++ [head==R1.head:e]))
		go(/\1)
		delete(fo(W))
		ttrput([x==conjunction:e|head==x:e])
		make(\/L)
		go(\/L)
		put(ty(e))
		put(fo(X))
		go(/\L)
		conjoin(X)
		go(/\0)
		go(\/1)
		delete(fo(U))
		ttrput(R1^(R1 ++ [head==R1.head:e]))
		go(/\1)
		conjoin(X)
		make(\/L)
		go(\/L)
		put(?ty(e))
		make(\/1)
		go(\/1)
		put(ty(e>e))
		ttrput(R1^(R1 ++ [x==conjunction:e||head==x|:ep==conjunct(x, R1.head):t]))
		go(/\1)
		make(\/0)
		go(\/0)
		put(?ty(e))
ELSE	abort

conj_entity_other(PRED)
IF		ty(e)
		fo(X)
		¬?+eval
		¬</\0\/1>ty(cn>e)
		<\/0>fo(W)
		<\/1>fo(U)
		<\/0\/0>fo(Y)
		<\/0\/1>fo(Z)
THEN	do_nothing
ELSE	abort

//*

		
		go(\/0)
		go(\/0)
		delete(fo(Y))
		go(/\0)
		go(\/1)
		delete(fo(Z))
		go(/\1)
		go(/\0)
		
		put(fo(X))
		put(?+eval)
		make(\/L)
		go(\/L)
		put(ty(e))
		put(fo(X))
		go(/\L)
put(?t)
		make(\/1)
		go(\/1)
		put(ty(e>t))
		ttrput(R1^(R1 ++ [e:es]))
		go(/\1)
		make(\/0)
		go(\/0)
ttrput((R1^R2^(R1 ++ (R2 ++ [x:e|p2==conj(x, R1.head):t])))
*//

conj_event(PRED)
IF		?ty(cn)
THEN	do_nothing
ELSE	abort

conj_prop(PRED)
IF		(ty(t) || ?ty(t))
		¬?+eval
THEN	put(?+eval)
		make(\/L)
		go(\/L)
		put(?ty(t))
ELSE	abort



//*
DISFLUENCY
*//

filler(PRED)
IF		X
THEN	do_nothing
ELSE	abort

disf(PRED)
IF		X
THEN	do_nothing
ELSE	abort