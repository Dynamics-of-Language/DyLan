// DS-RDF Lexical actions for English
// as per the DS-RDF project with Angus Addlesee & Arash Eshghi

// Rule metavariables: uppercase rule spec arguments
// Formula metavariables: A,B,C
// Bottom requirement: !

//@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .
//@prefix schema: <http://schema.org/> .
//@prefix dsrdf: <http://wallscope.co.uk/ontology/dsrdf/> .
//@prefix var: <http://wallscope.co.uk/ontology/var/> .



proper(NAME,PERSON,CLASS)
IF      ?ty(e)
		¬<\/1>Ex.x
        ¬<\/0>Ex.x
THEN    put(person(PERSON))
        put(ty(e))
        delete(?ty(e))
        rdfput({var:x a schema:Person, dsrdf:Head; rdfs:label "NAME"@en.})
ELSE    abort


//----- intransitive verbs

v_intran_inf(PRED,TENSE,PERSON)
IF		ty(e>t)
        ?Ex.fo(x)
        ¬<\/0>Ex.x
        ¬<\/1>Ex.x
THEN	delete(?Ex.fo(x))
		v_inran_content(PRED)
ELSE	abort

v_intran_ing(PRED,TENSE,PERSON)
IF		ty(e>t)
        ?Ex.fo(x)
        ¬<\/0>Ex.x
        ¬<\/1>Ex.x
        +BE
THEN	delete(?Ex.fo(x))
		v_intran_content(PRED)
ELSE	abort


v_intran_fin(PRED,TENSE,PERSON)
IF		?ty(e>t)
		¬<\/1>Ex.x
        ¬<\/0>Ex.x
		</\1\/0>person(PERSON)	
THEN	put(?+eval)
		make(\/L)
		go(\/L)
		put(ty(t))
		event_restrictor(TENSE)
		go(/\L)
		put(ty(e>t))
		delete(?ty(e>t))		
		put(?Ex.fo(x))
ELSE	abort
IF		ty(e>t)
        ?Ex.fo(x)
        ¬<\/0>Ex.x
        ¬<\/1>Ex.x
THEN	delete(?Ex.fo(x))
		v_intran_content(PRED)
ELSE	abort

//---------Transitive Verbs

v_tran_inf(PRED,TENSE,PERSON)
IF		ty(e>t)
        ?Ex.fo(x)
        ¬<\/0>Ex.x
        ¬<\/1>Ex.x
THEN	delete(?Ex.fo(x))
		delete(ty(e>t))
		put(?ty(e>t))		
		v_tran_content(PRED)
ELSE    abort

v_tran_ing(PRED,TENSE,PERSON)
IF		ty(e>t)
        ?Ex.fo(x)
        +BE
        ¬<\/0>Ex.x
        ¬<\/1>Ex.x
THEN	delete(?Ex.fo(x))
		delete(ty(e>t))
		put(?ty(e>t))
	    v_tran_content(PRED)
ELSE    abort

v_tran_fin(PRED,TENSE,PERSON)
IF		?ty(e>t)
		¬<\/1>Ex.x
        ¬<\/0>Ex.x
		</\1\/0>person(PERSON)
THEN	put(?+eval)
		make(\/L)
		go(\/L)
		put(ty(t))
		event_restrictor(TENSE)
		go(/\L)
		put(ty(e>t))	
		delete(?ty(e>t))	
		put(?Ex.fo(x))		
ELSE	abort
IF		ty(e>t)
        ?Ex.fo(x)
        ¬<\/0>Ex.x
        ¬<\/1>Ex.x
THEN	delete(?Ex.fo(x))
		delete(ty(e>t))
		put(?ty(e>t))		
		v_tran_content(PRED)
ELSE    abort

v_aux_inf(PRED,TENSE,PERSON)
IF		?ty(e>t)
		¬<\/1>Ex.x
	 	¬<\/0>Ex.x
	 	¬</\1/\0>Ex.x
		</\1\/0>ty(e)
THEN 	aux_content(PRED)
ELSE	IF		?ty(t)
				¬<\/1>Ex.x
	 			¬<\/0>Ex.x
	 			¬</\0>Ex.x				
		THEN	IF 		<\/*>+Q
				THEN    make(\/1)
						go(\/1)
						put(?ty(e>t))
						aux_content(PRED)
						go(/\1)
						make(\/0)
						go(\/0)
						put(?ty(e))
				ELSE	put(+Q)
						make(\/1)
						go(\/1)
						put(?ty(e>t))
						aux_content(PRED)
						go(/\1)
						make(\/0)
						go(\/0)
						put(?ty(e))
		ELSE	abort

manner_adv(PRED)
IF		(?ty(t) || ty(t) || ty(e>t))
		¬<\/L>Ex.x		
THEN	put(?+eval)
		make(\/L)
		go(\/L)
		put(ty(t))
		rdfput({var:e1 a dsrdf:Head; dsrdf:mod dsrdf:PRED.})
ELSE	abort


prep_es(PRED)
IF		ty(t)
		¬<\/L>Ex.x		
THEN	put(?+eval)
		make(\/L)
		go(\/L)
		put(?ty(t))
		make(\/1)
		go(\/1)
		put(ty(e>t))
		rdfput(G1^{var:e1 a dsrdf:head; dsrdf:PRED var:G1.})
		go(/\1)
		make(\/0)
		go(\/0)
		put(?ty(e))
		IF		</\0/\L\/*>?Ex.tn(x)
				</\0/\L\/*>ty(e)
		THEN	merge(</\0/\L\/*>)
				delete(?ty(e))
		ELSE	do_nothing
ELSE	abort


release_turn(PRED)
IF		ty(Y>Z)
THEN	abort
ELSE	IF		</\0\/1>Ex.x
				¬</\0\/1>Ex.?x
				¬Ex.?x
		THEN	abort
		ELSE	IF	  	ty(X)
					  	Speaker(W)
				THEN	IF		ty(t)
								+Q
						THEN	delete(+Q)
								put(Assert(W))
								ground
						ELSE	IF		<Z>+Q
								THEN	ground
								ELSE    IF		Assert(W)
										THEN	ground
										ELSE	put(Assert(W))
												ground	
				ELSE    abort
				


		